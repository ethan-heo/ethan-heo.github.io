# 블로그 아키텍처 STUDY 정리

## 1. 레이어드 아키텍처의 각 레이어 역할

### 1) 컨트롤러 (Controller)

- HTTP 요청/응답 처리, 라우팅, 인증 등
- 요청 데이터를 파싱하여 서비스(유즈케이스) 레이어를 호출
- 비즈니스 로직을 직접 수행하지 않음
- 서비스에서 반환된 결과를 HTTP 응답으로 변환해 클라이언트에 전달

### 2) 서비스/유즈케이스 (Service/Use Case)

- 비즈니스 시나리오(유즈케이스)를 구현하는 계층
- 여러 도메인 객체를 조합하거나 트랜잭션, 외부 시스템 호출 등 업무 흐름을 담당
- 도메인 로직(엔티티, 밸류 오브젝트, 도메인 서비스 등)을 호출하여 실제 처리를 수행
- 각 유즈케이스는 서비스 레이어의 메서드 또는 별도의 유즈케이스 클래스로 구현 가능

### 3) 도메인 (Domain)

- 시스템의 핵심 비즈니스 규칙과 상태 변화를 담당
- 도메인 모델(엔티티, 밸류 오브젝트, 도메인 서비스 등)을 정의
- 외부 서비스와 직접 통신하지 않음 (리포지토리 인터페이스를 통해 데이터 접근만 추상적으로 요청)

### 4) 인프라스트럭처 (Infrastructure)

- 실제 외부 시스템(API, DB 등)과의 통신을 담당
- 도메인/서비스 레이어에서 정의한 인터페이스(예: 리포지토리)를 구현

---

## 2. 각 레이어의 외부 통신 원칙

- **외부 데이터 소스와의 실제 통신은 인프라스트럭처 레이어에서만!**
- 도메인/서비스/컨트롤러는 외부 시스템에 직접 의존하지 않고, 인터페이스(리포지토리 등)를 통해 간접적으로 접근
- 이렇게 하면 코드가 더 유연하고, 테스트/유지보수가 쉬워짐

---

## 3. 서비스와 유즈케이스의 관계

- 서비스 레이어는 여러 유즈케이스(비즈니스 시나리오)를 구현하는 곳
- 유즈케이스는 서비스 레이어의 메서드이거나, 별도의 유즈케이스 클래스로 분리될 수도 있음
- 규모가 작으면 서비스 클래스에 유즈케이스 메서드를 모아두고, 크거나 복잡하면 유즈케이스별로 클래스를 분리

---

## 4. 비즈니스 로직과 서비스 로직의 차이

| 구분          | 위치          | 역할/예시                                            |
| ------------- | ------------- | ---------------------------------------------------- |
| 비즈니스 로직 | 도메인 레이어 | 핵심 규칙, 상태 변화, 도메인 엔티티/서비스 등        |
| 서비스 로직   | 서비스 레이어 | 유즈케이스, 도메인 객체 조합, 트랜잭션, 외부 호출 등 |

- **비즈니스 로직**: 시스템의 핵심 규칙(예: 게시글은 반드시 제목이 있어야 한다)
- **서비스 로직**: 유즈케이스(업무 시나리오) 구현, 여러 도메인 객체 조합, 트랜잭션, 외부 시스템 호출 등

---

## 5. 예시 코드

```typescript
// 도메인 레이어 (비즈니스 로직)
class Blog {
    publish() {
        if (!this.title) throw new Error("제목이 필요합니다");
        this.published = true;
    }
}

// 리포지토리 인터페이스 (도메인에서 정의)
interface BlogRepository {
    findById(id: string): Promise<Blog>;
    save(blog: Blog): Promise<void>;
}

// 인프라스트럭처 레이어 (외부 서비스와 통신)
class NotionBlogRepository implements BlogRepository {
    async findById(id: string) {
        /* Notion API 호출 */
    }
    async save(blog: Blog) {
        /* Notion API 호출 */
    }
}

// 서비스 레이어 (서비스 로직/유즈케이스)
class BlogService {
    constructor(private blogRepository: BlogRepository) {}
    async publishBlog(id) {
        const blog = await this.blogRepository.findById(id);
        blog.publish(); // 비즈니스 로직 호출
        await this.blogRepository.save(blog);
        // 예: 알림 전송 등 추가 업무 처리
    }
}

// 컨트롤러
app.post("/blog/:id/publish", async (req, res) => {
    await blogService.publishBlog(req.params.id);
    res.status(200).send("Published");
});
```

---

## 6. 한 줄 요약

- 컨트롤러: 요청을 받아 서비스에 전달, 결과를 응답으로 반환
- 서비스/유즈케이스: 기능 단위의 작업(비즈니스 시나리오) 구현, 도메인 로직 호출/조합
- 도메인: 핵심 비즈니스 규칙과 상태 변화 담당, 외부 통신 X
- 인프라스트럭처: 외부 시스템과의 실제 통신 담당
- **비즈니스 로직**은 도메인에, **서비스 로직**은 서비스/유즈케이스에 위치

---

## 7. 레포지토리의 역할

- 레포지토리는 도메인/서비스와 외부 데이터 소스(서비스, DB, API 등) 사이의 중간자 역할을 하며, 데이터 요청/응답을 추상화합니다.
- 도메인/서비스 레이어는 레포지토리의 **인터페이스**만 알고, 실제 구현(외부 서비스와의 통신)은 인프라스트럭처 레이어에서 담당합니다.
- 한 줄 요약: **레포지토리는 외부 데이터 소스와의 통신을 추상화하여, 도메인/서비스가 외부 시스템에 직접 의존하지 않도록 해줍니다.**

---

## 8. 서비스, 도메인, 레포지토리의 의존성 및 단방향성

- 서비스 레이어는 도메인 로직(엔티티, 밸류 오브젝트, 도메인 서비스 등)과 레포지토리 **인터페이스**를 함께 사용합니다.
- 서비스/도메인 레이어가 레포지토리 **구현체**(예: NotionBlogRepository)에 직접 의존하면 인프라스트럭처(외부 시스템)에 강하게 결합되어 단방향 의존성 원칙이 깨집니다.
- 항상 인터페이스(추상화)에 의존하고, 실제 구현체는 DI(의존성 주입)로 주입받아 사용해야 합니다.
- 한 줄 요약: **서비스는 도메인 로직과 레포지토리 인터페이스를 함께 사용하며, 레포지토리 구현체에는 직접 의존하지 않는 것이 올바른 구조입니다.**

---

## 9. 레이어드 아키텍처에서의 추천 구현 순서

1. 도메인 레이어(엔티티, 밸류 오브젝트, 도메인 서비스 등)부터 구현: 시스템의 핵심 규칙과 불변의 비즈니스 로직을 먼저 설계
2. 레포지토리 인터페이스 정의: 도메인/서비스에서 사용할 데이터 접근 추상화
3. 서비스/유즈케이스 레이어 구현: 도메인 객체와 레포지토리 인터페이스를 활용해 유즈케이스(업무 시나리오) 구현
4. 레포지토리 구현체(인프라스트럭처) 작성: 실제 외부 시스템(API, DB 등)과 통신하는 구현체
5. 컨트롤러 구현: HTTP 요청/응답 처리, 라우팅 등

- 이렇게 하면 비즈니스 규칙이 중심이 되고, 외부 시스템에 의존하지 않고 테스트/개발이 쉬워집니다.
- 한 줄 요약: **“도메인 → 레포지토리 인터페이스 → 서비스/유즈케이스 → 레포지토리 구현체 → 컨트롤러” 순서로 구현하는 것이 가장 이상적입니다.**
